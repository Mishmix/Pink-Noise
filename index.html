<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="theme-color" content="#000000">
<meta name="mobile-web-app-capable" content="yes">
<title>Sleep Noise</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸŒ™</text></svg>">
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
:root{
  --bg:#000;--s1:#0a0a0a;--s2:#111;
  --t1:#b8b0a4;--t2:#5a5550;--t3:#3a3632;
  --ac:#c8956c;--acd:rgba(200,149,108,.06);
  --font:-apple-system,'SF Pro Display','Helvetica Neue',system-ui,sans-serif;
  --ease:cubic-bezier(.4,0,.2,1);
  --sat:env(safe-area-inset-top,0px);--sab:env(safe-area-inset-bottom,0px);
}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--t1);font-family:var(--font);-webkit-font-smoothing:antialiased}
body{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:calc(var(--sat) + 20px) 24px calc(var(--sab) + 20px);position:relative}
*{-webkit-user-select:none;user-select:none}

#viz{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;opacity:0;transition:opacity 3s ease}
#viz.active{opacity:1}

.app{position:relative;z-index:1;display:flex;flex-direction:column;align-items:center;gap:40px;width:100%;max-width:380px}

.header{text-align:center;opacity:0;animation:fu 1s var(--ease) .2s forwards}
.header h1{font-size:13px;font-weight:500;letter-spacing:3px;text-transform:uppercase;color:var(--t2);margin-bottom:6px}
.header .sub{font-size:11px;letter-spacing:1.5px;color:var(--t3);text-transform:uppercase}

.noise-toggle{
  display:flex;align-items:center;
  background:var(--s1);border-radius:100px;
  padding:3px;border:1px solid rgba(200,149,108,.08);
  position:relative;
  opacity:0;animation:fu 1s var(--ease) .3s forwards;
}
.noise-btn{
  position:relative;z-index:1;
  padding:9px 24px;border-radius:100px;
  border:none;background:transparent;
  color:var(--t2);font-family:var(--font);
  font-size:13px;font-weight:500;letter-spacing:.8px;
  cursor:pointer;outline:none;transition:color .4s ease;
}
.noise-btn.on{color:var(--t1)}
.noise-pill{
  position:absolute;top:3px;left:3px;
  height:calc(100% - 6px);border-radius:100px;
  background:var(--s2);border:1px solid rgba(200,149,108,.1);
  transition:all .4s var(--ease);pointer-events:none;
}

.pw{position:relative;opacity:0;animation:fu 1s var(--ease) .4s forwards}
.pb{width:156px;height:156px;border-radius:50%;border:1.5px solid rgba(200,149,108,.12);background:var(--s1);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .6s var(--ease);position:relative;outline:none}
.pb::before{content:'';position:absolute;inset:-1px;border-radius:50%;background:radial-gradient(circle at 50% 40%,rgba(200,149,108,.04),transparent 70%);pointer-events:none}
.pb:active{transform:scale(.95)}
.pb.on{border-color:rgba(200,149,108,.25);box-shadow:0 0 60px rgba(200,149,108,.08),0 0 120px rgba(200,149,108,.03)}
.ip,.iq{transition:opacity .4s,transform .4s;position:absolute}
.ip{opacity:1;transform:scale(1)}.iq{opacity:0;transform:scale(.8)}
.pb.on .ip{opacity:0;transform:scale(.8)}.pb.on .iq{opacity:1;transform:scale(1)}
.ring{position:absolute;inset:-20px;border-radius:50%;border:1px solid transparent;pointer-events:none}
.pb.on~.ring{animation:br 6s ease-in-out infinite}
@keyframes br{0%,100%{transform:scale(1);border-color:rgba(200,149,108,.04)}50%{transform:scale(1.08);border-color:rgba(200,149,108,.12)}}

.controls{width:100%;display:flex;flex-direction:column;align-items:center;gap:28px;opacity:0;animation:fu 1s var(--ease) .6s forwards}

.vr{display:flex;align-items:center;gap:14px;width:100%;max-width:260px}
.vi{flex-shrink:0;color:var(--t3)}.vi.h{color:var(--t2)}
.st{flex:1;height:36px;display:flex;align-items:center;cursor:pointer;touch-action:none}
.sb{width:100%;height:3px;background:var(--s2);border-radius:2px;position:relative}
.sf{height:100%;background:var(--ac);border-radius:2px;width:70%;transition:width 50ms linear;position:relative}
.sth{position:absolute;right:-7px;top:50%;transform:translateY(-50%);width:14px;height:14px;border-radius:50%;background:var(--t1);box-shadow:0 0 10px rgba(0,0,0,.5);transition:transform .15s}
.st:active .sth{transform:translateY(-50%) scale(1.3)}

.ts{text-align:center;width:100%}
.tl{font-size:10px;letter-spacing:2px;text-transform:uppercase;color:var(--t3);margin-bottom:12px}
.to{display:flex;justify-content:center;gap:6px;flex-wrap:wrap;max-width:340px;margin:0 auto}
.tb{padding:7px 14px;border-radius:100px;border:1px solid transparent;background:var(--s1);color:var(--t2);font-family:var(--font);font-size:13px;font-weight:500;cursor:pointer;transition:all .3s;outline:none;letter-spacing:.3px}
.tb:active{transform:scale(.95)}
.tb.on{border-color:rgba(200,149,108,.2);color:var(--ac);background:var(--acd)}

.custom-row{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:10px}
.custom-input{
  width:64px;height:34px;border-radius:100px;
  border:1px solid rgba(200,149,108,.12);background:var(--s1);color:var(--t1);
  font-family:var(--font);font-size:14px;font-weight:500;text-align:center;outline:none;
  -webkit-user-select:text;user-select:text;transition:border-color .3s;
}
.custom-input:focus{border-color:rgba(200,149,108,.3)}
.custom-input::placeholder{color:var(--t3);font-size:12px}
.custom-input::-webkit-inner-spin-button,.custom-input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
.custom-input{-moz-appearance:textfield}
.custom-unit{font-size:12px;color:var(--t3);letter-spacing:.5px}
.custom-set{
  padding:7px 14px;border-radius:100px;border:1px solid rgba(200,149,108,.15);
  background:transparent;color:var(--ac);font-family:var(--font);font-size:12px;
  font-weight:500;cursor:pointer;outline:none;transition:all .3s;letter-spacing:.3px;
}
.custom-set:active{transform:scale(.95);background:var(--acd)}

.cd{margin-top:12px;font-size:32px;font-weight:300;letter-spacing:2px;color:var(--t3);font-variant-numeric:tabular-nums;min-height:40px;transition:color .5s}
.cd.vis{color:var(--t2)}
/* Paused timer blinks gently */
.cd.paused{animation:blink 2s ease-in-out infinite}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.35}}

@keyframes fu{from{opacity:0;transform:translateY(16px)}to{opacity:1;transform:translateY(0)}}
@media(max-height:700px){.app{gap:24px}.pb{width:130px;height:130px}.controls{gap:20px}.cd{font-size:26px;min-height:32px}}
@media(min-width:768px){.pb{width:180px;height:180px}.pb:hover{border-color:rgba(200,149,108,.2);box-shadow:0 0 40px rgba(200,149,108,.05)}}
</style>
</head>
<body>

<canvas id="viz"></canvas>

<div class="app">
  <div class="header">
    <h1>Sleep Noise</h1>
    <div class="sub">Deep Sleep Generator</div>
  </div>

  <div class="noise-toggle" id="noiseToggle">
    <button class="noise-btn on" data-type="pink" id="btnPink">Pink</button>
    <button class="noise-btn" data-type="brown" id="btnBrown">Brown</button>
    <div class="noise-pill" id="noisePill"></div>
  </div>

  <div class="pw">
    <button class="pb" id="pb" aria-label="Play">
      <svg class="ip" width="38" height="38" viewBox="0 0 40 40" fill="none">
        <path d="M14 8.5L33 20L14 31.5V8.5Z" fill="#b8b0a4" opacity=".8"/>
      </svg>
      <svg class="iq" width="38" height="38" viewBox="0 0 40 40" fill="none">
        <rect x="11" y="9" width="6" height="22" rx="2" fill="#c8956c" opacity=".9"/>
        <rect x="23" y="9" width="6" height="22" rx="2" fill="#c8956c" opacity=".9"/>
      </svg>
    </button>
    <div class="ring"></div>
  </div>

  <div class="controls">
    <div class="vr">
      <svg class="vi" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 5L6 9H2v6h4l5 4V5z"/>
      </svg>
      <div class="st" id="st">
        <div class="sb">
          <div class="sf" id="sf"><div class="sth"></div></div>
        </div>
      </div>
      <svg class="vi h" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 5L6 9H2v6h4l5 4V5z"/>
        <path d="M19.07 4.93a10 10 0 010 14.14M15.54 8.46a5 5 0 010 7.08"/>
      </svg>
    </div>

    <div class="ts">
      <div class="tl">Sleep Timer</div>
      <div class="to">
        <button class="tb" data-m="30">30m</button>
        <button class="tb" data-m="60">1h</button>
        <button class="tb" data-m="120">2h</button>
        <button class="tb" data-m="180">3h</button>
        <button class="tb" data-m="240">4h</button>
        <button class="tb on" data-m="0">âˆ</button>
      </div>
      <div class="custom-row">
        <input class="custom-input" id="custIn" type="number" inputmode="numeric" placeholder="min" min="1" max="720">
        <span class="custom-unit">Ğ¼Ğ¸Ğ½</span>
        <button class="custom-set" id="custSet">Set</button>
      </div>
      <div class="cd" id="cd"></div>
    </div>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SLEEP NOISE GENERATOR v5
   Pink (-3dB/oct) + Brown (-6dB/oct) Â· True Stereo
   
   BACKGROUND AUDIO STRATEGY:
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Mobile browsers aggressively suspend audio when:
   - Screen locks
   - Browser goes to background
   - Tab switches
   
   Countermeasures used (layered defense):
   
   1. Silent <audio> loop â€” keeps the browser audio session
      "active" at OS level. This is the #1 most reliable trick.
      The browser thinks media is playing â†’ doesn't kill the tab.
   
   2. Media Session API â€” registers play/pause handlers so the
      OS shows lock-screen controls. This signals to the browser
      that this tab is an active media player.
   
   3. Web Locks API â€” navigator.locks.request() prevents the
      browser from freezing/discarding the tab. Works in Chrome.
   
   4. Wake Lock API â€” keeps screen on (optional, for when user
      wants to see the timer counting down).
   
   5. Visibility change handler â€” when tab regains focus,
      immediately resumes AudioContext if it was suspended.
   
   6. Periodic AudioContext check â€” setInterval pings the
      context state every 10s and resumes if suspended.
   
   TIMER BEHAVIOR:
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Pause does NOT reset the timer. It freezes remaining time.
   Play resumes the timer from where it was paused.
   Selecting a new timer duration resets it (as expected).
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// â”€â”€â”€ State â”€â”€â”€
let playing = false, vol = 0.7, noiseType = 'pink';
let audioCtx = null, gainNode = null, scriptNode = null;
let lowShelf = null, highShelf = null;
let wakeLockRef = null;

// Timer state: remainingMs persists across pause/play
let timerTotalSec = 0;     // 0 = infinity
let timerRemainingMs = 0;  // ms left (survives pause)
let timerEnd = null;       // absolute timestamp when timer expires
let timerIv = null;        // setInterval ref

// Noise filter states
const pL = new Float64Array(7), pR = new Float64Array(7);
let brL = 0, brR = 0;

// â”€â”€â”€ Noise Generators â”€â”€â”€
function pinkSample(b) {
  const w = Math.random() * 2 - 1;
  b[0] = 0.99886 * b[0] + w * 0.0555179;
  b[1] = 0.99332 * b[1] + w * 0.0750759;
  b[2] = 0.96900 * b[2] + w * 0.1538520;
  b[3] = 0.86650 * b[3] + w * 0.3104856;
  b[4] = 0.55000 * b[4] + w * 0.5329522;
  b[5] = -0.7616 * b[5] - w * 0.0168980;
  const out = b[0] + b[1] + b[2] + b[3] + b[4] + b[5] + b[6] + w * 0.5362;
  b[6] = w * 0.115926;
  return out * 0.11;
}

function brownSampleL() {
  brL = 0.998 * brL + (Math.random() * 2 - 1) * 0.02;
  return Math.tanh(brL * 0.8);
}
function brownSampleR() {
  brR = 0.998 * brR + (Math.random() * 2 - 1) * 0.02;
  return Math.tanh(brR * 0.8);
}

// â”€â”€â”€ Audio Engine â”€â”€â”€
function ensureAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  scriptNode = audioCtx.createScriptProcessor(4096, 0, 2);
  scriptNode.onaudioprocess = function(e) {
    const L = e.outputBuffer.getChannelData(0);
    const R = e.outputBuffer.getChannelData(1);
    if (noiseType === 'pink') {
      for (let i = 0; i < L.length; i++) { L[i] = pinkSample(pL); R[i] = pinkSample(pR); }
    } else {
      for (let i = 0; i < L.length; i++) { L[i] = brownSampleL(); R[i] = brownSampleR(); }
    }
  };

  lowShelf = audioCtx.createBiquadFilter();
  lowShelf.type = 'lowshelf';
  highShelf = audioCtx.createBiquadFilter();
  highShelf.type = 'highshelf';
  applyEQ();

  gainNode = audioCtx.createGain();
  gainNode.gain.value = 0;

  scriptNode.connect(lowShelf);
  lowShelf.connect(highShelf);
  highShelf.connect(gainNode);
  gainNode.connect(audioCtx.destination);
}

function applyEQ() {
  if (!lowShelf) return;
  if (noiseType === 'pink') {
    lowShelf.frequency.value = 80; lowShelf.gain.value = 1.5;
    highShelf.frequency.value = 12000; highShelf.gain.value = -1.0;
  } else {
    lowShelf.frequency.value = 40; lowShelf.gain.value = -2.0;
    highShelf.frequency.value = 8000; highShelf.gain.value = 0.5;
  }
}

// â”€â”€â”€ Fade â”€â”€â”€
const FADE = 2.5;
function fadeIn() {
  const g = gainNode.gain, t = audioCtx.currentTime;
  g.cancelScheduledValues(t); g.setValueAtTime(g.value, t);
  g.linearRampToValueAtTime(vol, t + FADE);
}
function fadeOut(cb) {
  const g = gainNode.gain, t = audioCtx.currentTime;
  g.cancelScheduledValues(t); g.setValueAtTime(g.value, t);
  g.linearRampToValueAtTime(0.0001, t + FADE);
  setTimeout(cb, FADE * 1000 + 100);
}
function crossfade() {
  const g = gainNode.gain, t = audioCtx.currentTime;
  g.cancelScheduledValues(t); g.setValueAtTime(g.value, t);
  g.linearRampToValueAtTime(0.0001, t + 0.5);
  setTimeout(() => {
    applyEQ();
    const t2 = audioCtx.currentTime;
    g.cancelScheduledValues(t2); g.setValueAtTime(0.0001, t2);
    g.linearRampToValueAtTime(vol, t2 + 0.5);
  }, 550);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BACKGROUND AUDIO â€” layered defense system
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 1. Silent audio loop â€” keeps audio session alive at OS level
let silentAudio = null;
function createSilentAudio() {
  if (silentAudio) return;
  // Generate a 1-second silent WAV in-memory
  // 44100 samples Ã— 2 bytes Ã— 1 channel = 88200 bytes of silence
  silentAudio = new Audio();
  silentAudio.src = createSilentWavUrl(2); // 2 seconds of silence
  silentAudio.loop = true;
  silentAudio.volume = 0.001; // Near-silent but non-zero
  silentAudio.setAttribute('playsinline', '');
}

function createSilentWavUrl(durationSec) {
  const sampleRate = 8000; // Low rate = small file
  const numSamples = sampleRate * durationSec;
  const dataSize = numSamples * 2; // 16-bit mono
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);

  // WAV header
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);     // chunk size
  view.setUint16(20, 1, true);      // PCM
  view.setUint16(22, 1, true);      // mono
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true); // byte rate
  view.setUint16(32, 2, true);      // block align
  view.setUint16(34, 16, true);     // bits per sample
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);
  // Data section is all zeros = silence

  const blob = new Blob([buffer], { type: 'audio/wav' });
  return URL.createObjectURL(blob);
}

function writeString(view, offset, str) {
  for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
}

function startSilentAudio() {
  createSilentAudio();
  const p = silentAudio.play();
  if (p) p.catch(() => {}); // Ignore autoplay blocks
}

function stopSilentAudio() {
  if (silentAudio) { silentAudio.pause(); silentAudio.currentTime = 0; }
}

// 2. Media Session API
function setupMediaSession() {
  if (!('mediaSession' in navigator)) return;
  navigator.mediaSession.metadata = new MediaMetadata({
    title: noiseType === 'pink' ? 'Pink Noise' : 'Brown Noise',
    artist: 'Sleep Noise',
    album: 'Deep Sleep'
  });
  navigator.mediaSession.setActionHandler('play', () => { if (!playing) toggle(); });
  navigator.mediaSession.setActionHandler('pause', () => { if (playing) toggle(); });
  navigator.mediaSession.setActionHandler('stop', () => { if (playing) toggle(); });
  navigator.mediaSession.playbackState = 'playing';
}

// 3. Web Locks API â€” prevents tab discard/freeze
let webLockController = null;
function acquireWebLock() {
  if (!('locks' in navigator)) return;
  // AbortController lets us release the lock later
  webLockController = new AbortController();
  navigator.locks.request('sleep-noise-playing', { signal: webLockController.signal }, () => {
    // Hold the lock until aborted â€” return a never-resolving promise
    return new Promise(() => {});
  }).catch(() => {}); // Catch abort
}
function releaseWebLock() {
  if (webLockController) { webLockController.abort(); webLockController = null; }
}

// 4. Wake Lock API
async function acquireWakeLock() {
  try {
    if ('wakeLock' in navigator) wakeLockRef = await navigator.wakeLock.request('screen');
  } catch(_) {}
}
function releaseWakeLock() {
  if (wakeLockRef) { wakeLockRef.release().catch(() => {}); wakeLockRef = null; }
}

// 5. Periodic AudioContext health check
let healthCheckIv = null;
function startHealthCheck() {
  healthCheckIv = setInterval(() => {
    if (playing && audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }, 10000); // Every 10 seconds
}
function stopHealthCheck() {
  if (healthCheckIv) { clearInterval(healthCheckIv); healthCheckIv = null; }
}

// 6. Visibility change handler
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && playing) {
    // Tab regained focus â€” make sure everything is running
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    acquireWakeLock();
    // Re-sync timer display (time kept ticking via timerEnd timestamp)
    if (timerEnd) tickFn();
  }
});

// â”€â”€â”€ Play / Stop â”€â”€â”€
async function toggle() {
  ensureAudio();
  if (audioCtx.state === 'suspended') await audioCtx.resume();
  playing ? doPause() : doStart();
}

function doStart() {
  playing = true;
  document.getElementById('pb').classList.add('on');
  document.getElementById('viz').classList.add('active');

  // Reset noise states only on fresh start (not resume)
  if (gainNode.gain.value < 0.001) { pL.fill(0); pR.fill(0); brL = 0; brR = 0; }

  fadeIn();

  // Resume or start timer
  resumeTimer();

  // Activate all background persistence layers
  startSilentAudio();
  setupMediaSession();
  acquireWebLock();
  acquireWakeLock();
  startHealthCheck();
}

function doPause() {
  // Freeze timer (save remaining time)
  pauseTimer();

  fadeOut(() => {
    playing = false;
    document.getElementById('pb').classList.remove('on');
    document.getElementById('viz').classList.remove('active');

    // Release background locks
    stopSilentAudio();
    releaseWebLock();
    releaseWakeLock();
    stopHealthCheck();
    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused';
  });
}

function doFullStop() {
  // Called by timer expiry â€” full reset
  fadeOut(() => {
    playing = false;
    document.getElementById('pb').classList.remove('on');
    document.getElementById('viz').classList.remove('active');
    timerRemainingMs = 0;
    timerEnd = null;
    stopTimerInterval();
    updateTimerDisplay(0);
    document.getElementById('cd').classList.remove('vis', 'paused');

    stopSilentAudio();
    releaseWebLock();
    releaseWakeLock();
    stopHealthCheck();
    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = 'paused';
  });
}

// â”€â”€â”€ Volume â”€â”€â”€
function setVol(v) {
  vol = Math.max(0, Math.min(1, v));
  document.getElementById('sf').style.width = (vol * 100) + '%';
  if (playing && gainNode) {
    const t = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(t);
    gainNode.gain.setTargetAtTime(vol, t, 0.03);
  }
}

let drag = false;
const stEl = document.getElementById('st');
function onSl(e) {
  const r = stEl.getBoundingClientRect();
  setVol(((e.touches ? e.touches[0].clientX : e.clientX) - r.left) / r.width);
}
stEl.addEventListener('pointerdown', e => { drag=true; stEl.setPointerCapture(e.pointerId); onSl(e); });
stEl.addEventListener('pointermove', e => { if(drag) onSl(e); });
stEl.addEventListener('pointerup', () => drag=false);
stEl.addEventListener('pointercancel', () => drag=false);

// â”€â”€â”€ Noise Type Switch â”€â”€â”€
const btnPink = document.getElementById('btnPink');
const btnBrown = document.getElementById('btnBrown');
const pill = document.getElementById('noisePill');

function positionPill() {
  const active = noiseType === 'pink' ? btnPink : btnBrown;
  const parent = document.getElementById('noiseToggle');
  const pr = parent.getBoundingClientRect();
  const ar = active.getBoundingClientRect();
  pill.style.width = ar.width + 'px';
  pill.style.left = (ar.left - pr.left) + 'px';
}

function switchNoise(type) {
  if (type === noiseType) return;
  noiseType = type;
  btnPink.classList.toggle('on', type === 'pink');
  btnBrown.classList.toggle('on', type === 'brown');
  positionPill();
  document.querySelector('.header .sub').textContent =
    type === 'pink' ? 'Pink Â· Deep Sleep' : 'Brown Â· Deep Sleep';
  vizHue = type === 'pink' ? '200,149,108' : '160,140,120';
  if (playing) {
    crossfade();
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: type === 'pink' ? 'Pink Noise' : 'Brown Noise',
        artist: 'Sleep Noise'
      });
    }
  } else { applyEQ(); }
}

btnPink.addEventListener('click', () => switchNoise('pink'));
btnBrown.addEventListener('click', () => switchNoise('brown'));
requestAnimationFrame(() => requestAnimationFrame(positionPill));
addEventListener('resize', positionPill);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TIMER â€” pause/resume logic
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Select timer duration (resets remaining time)
function selectTimer(totalSec) {
  timerTotalSec = totalSec;
  timerRemainingMs = totalSec * 1000; // Reset remaining
  timerEnd = null;

  document.querySelectorAll('.tb').forEach(x => x.classList.remove('on'));
  if (totalSec === 0) {
    document.querySelector('.tb[data-m="0"]').classList.add('on');
  } else {
    const mins = totalSec / 60;
    const btn = document.querySelector(`.tb[data-m="${mins}"]`);
    if (btn) btn.classList.add('on');
  }

  // If playing, restart the timer with new duration
  if (playing) {
    stopTimerInterval();
    resumeTimer();
  } else {
    // Not playing: show the selected duration statically
    stopTimerInterval();
    if (totalSec > 0) {
      updateTimerDisplay(totalSec * 1000);
      document.getElementById('cd').classList.add('vis');
      document.getElementById('cd').classList.remove('paused');
    } else {
      document.getElementById('cd').textContent = '';
      document.getElementById('cd').classList.remove('vis', 'paused');
    }
  }
}

// Resume timer from timerRemainingMs
function resumeTimer() {
  stopTimerInterval();
  const cd = document.getElementById('cd');
  cd.classList.remove('paused');

  if (timerTotalSec <= 0 || timerRemainingMs <= 0) {
    cd.textContent = ''; cd.classList.remove('vis');
    return;
  }

  timerEnd = Date.now() + timerRemainingMs;
  cd.classList.add('vis');
  tickFn();
  timerIv = setInterval(tickFn, 1000);
}

// Pause timer: save remaining, stop interval
function pauseTimer() {
  if (timerEnd) {
    timerRemainingMs = Math.max(0, timerEnd - Date.now());
    timerEnd = null;
  }
  stopTimerInterval();

  const cd = document.getElementById('cd');
  if (timerTotalSec > 0 && timerRemainingMs > 0) {
    cd.classList.add('paused'); // Blinking effect
    updateTimerDisplay(timerRemainingMs);
  }
}

function stopTimerInterval() {
  if (timerIv) { clearInterval(timerIv); timerIv = null; }
}

function tickFn() {
  const rem = Math.max(0, timerEnd - Date.now());

  if (rem <= 0) {
    doFullStop();
    return;
  }

  // Gentle fade before timer expires
  const fadeMs = Math.min(10000, timerTotalSec * 500);
  if (rem <= fadeMs && playing && gainNode) {
    const g = gainNode.gain, t = audioCtx.currentTime;
    if (g.value > 0.01) {
      g.cancelScheduledValues(t); g.setValueAtTime(g.value, t);
      g.linearRampToValueAtTime(0.0001, t + rem / 1000);
    }
  }

  updateTimerDisplay(rem);
}

function updateTimerDisplay(ms) {
  const cd = document.getElementById('cd');
  if (ms <= 0) { cd.textContent = ''; return; }
  const s = Math.ceil(ms / 1000);
  const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60), sc = s % 60;
  cd.textContent = h > 0
    ? `${h}:${String(m).padStart(2,'0')}:${String(sc).padStart(2,'0')}`
    : `${m}:${String(sc).padStart(2,'0')}`;
}

// Timer button handlers
document.querySelectorAll('.tb').forEach(b => {
  b.addEventListener('click', () => selectTimer((+b.dataset.m) * 60));
});

document.getElementById('custSet').addEventListener('click', () => {
  const v = parseInt(document.getElementById('custIn').value);
  if (v > 0 && v <= 720) {
    selectTimer(v * 60);
    document.getElementById('custIn').value = '';
    document.getElementById('custIn').blur();
  }
});
document.getElementById('custIn').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') document.getElementById('custSet').click();
});

// Play button
document.getElementById('pb').addEventListener('click', toggle);

// â”€â”€â”€ Canvas Viz â”€â”€â”€
const cvs = document.getElementById('viz');
const cx = cvs.getContext('2d');
let vizHue = '200,149,108';
const cir = Array.from({length:5}, (_,i) => ({
  x:.5, y:.45+i*.03, br:.12+i*.06, ph:i*1.2, sp:.15+i*.05, op:.025-i*.003
}));

function rsz() {
  const d = Math.min(devicePixelRatio||1, 2);
  cvs.width=innerWidth*d; cvs.height=innerHeight*d;
  cvs.style.width=innerWidth+'px'; cvs.style.height=innerHeight+'px';
  cx.scale(d,d);
}
rsz(); addEventListener('resize', rsz);

(function loop() {
  requestAnimationFrame(loop);
  const w=innerWidth, h=innerHeight, t=performance.now()/1000;
  cx.clearRect(0,0,w,h);
  if (!playing) return;
  for (const c of cir) {
    const b = Math.sin(t*c.sp+c.ph)*.5+.5;
    const r = c.br*h*(.8+b*.4);
    const px = c.x*w + Math.sin(t*.1+c.ph)*10;
    const py = c.y*h + Math.cos(t*.08+c.ph)*8;
    const g = cx.createRadialGradient(px,py,0,px,py,r);
    g.addColorStop(0, `rgba(${vizHue},${c.op*(.7+b*.3)})`);
    g.addColorStop(.5, `rgba(${vizHue},${c.op*.3})`);
    g.addColorStop(1, `rgba(${vizHue},0)`);
    cx.beginPath(); cx.arc(px,py,r,0,Math.PI*2); cx.fillStyle=g; cx.fill();
  }
})();

setVol(0.7);
</script>
</body>
</html>
